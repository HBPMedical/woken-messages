# ========================================= #
# Shared Woken Reference Configuration      #
# ========================================= #

app {
  # Name of the application
  name = ${?APP_NAME}
  # Type of the application
  type = ${?APP_TYPE}
  # Version of the application
  version = ${?VERSION}
  # Date when this application was built
  buildDate = ${?BUILD_DATE}
}

datacenter {
  # Location of the datacenter
  location = "dev"
  location = ${?DATA_CENTER_LOCATION}
  host = ""
  host = ${?HOST}
  # Container orchestration
  containerOrchestration = "mesos"
  containerOrchestration = ${?CONTAINER_ORCHESTRATION}
  # Mesos properties
  mesos {
    containerName = ""
    containerName = ${?MESOS_CONTAINER_NAME}
    dockerImage = ""
    dockerImage = ${?MARATHON_APP_DOCKER_IMAGE}
    resourceCpu = ""
    resourceCpu = ${?MARATHON_APP_RESOURCE_CPUS}
    resourceMem = ""
    resourceMem = ${?MARATHON_APP_RESOURCE_MEM}
    labels = ""
    labels = ${?MARATHON_APP_LABELS}
  }
}

bugsnag {
  apiKey = ${?BUGSNAG_KEY}
  # Release stage used when reporting errors. Values are dev, staging, production
  releaseStage = "dev"
  releaseStage = ${?RELEASE_STAGE}
}

# Common settings for Akka

akka {
  loglevel = "WARNING"
  loglevel = ${?AKKA_LOG_LEVEL}
  stdout-loglevel = "WARNING"
  stdout-loglevel = ${?AKKA_LOG_LEVEL}
  loggers = ["akka.event.slf4j.Slf4jLogger"]
  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"

  log-config-on-start = off
  log-config-on-start = ${?AKKA_LOG_CONFIG}

  log-dead-letters = 10
  log-dead-letters-during-shutdown = off

  coordinated-shutdown.terminate-actor-system = on

  actor {
    # provider = "cluster"

    debug {
      receive = on
      autoreceive = off
      lifecycle = on
      fsm = off
      unhandled = on
      event-stream = off
    }

    serializers {
      woken-messages-serializer = "ch.chuv.lren.woken.messages.AkkaSerializer"
    }

    serialization-bindings {
      "ch.chuv.lren.woken.messages.Ping" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.Pong" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.ComponentQuery" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.ComponentQuery" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.VersionQuery" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.VersionResponse" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.datasets.DatasetsQuery" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.datasets.DatasetsResponse" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.datasets.TablesQuery" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.datasets.TablesResponse" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.query.MethodsQuery$" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.query.MethodsResponse" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.query.MiningQuery" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.query.ExperimentQuery" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.query.QueryResult" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.validation.ValidationQuery" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.validation.ValidationResult" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.validation.ScoringQuery" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.validation.ScoringResult" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.variables.VariablesForDatasetsQuery" = woken-messages-serializer
      "ch.chuv.lren.woken.messages.variables.VariablesForDatasetsResponse" = woken-messages-serializer
    }

    enable-additional-serialization-bindings = on
    allow-java-serialization = off

  }

  remote {
    log-sent-messages = off
    log-received-messages = off
    log-remote-lifecycle-events = off

    watch-failure-detector {
      acceptable-heartbeat-pause = 20 s
    }

  }

  cluster {
    seed-nodes = [
      ${remoting.protocol}"://"${clustering.cluster.name}"@"${clustering.seed-ip}":"${clustering.seed-port}
    ]

    shutdown-after-unsuccessful-join-seed-nodes = 20s

    role {
      woken.min-nr-of-members = 1
      validation.min-nr-of-members = 0
      validation.min-nr-of-members = ${?VALIDATION_MIN_SERVERS}
      scoring.min-nr-of-members = 0
      validation.min-nr-of-members = ${?SCORING_MIN_SERVERS}
    }

    client {
      initial-contacts = [${remoting.protocol}"://"${clustering.cluster.name}"@"${clustering.seed-ip}":"${clustering.seed-port}"/system/receptionist"]

      receptionist {
        response-tunnel-receive-timeout = 60s
      }
    }
  }

  http {
    server {
      idle-timeout = 300s
      request-timeout = 180s
      ssl-encryption = off
      ssl-tracing = on
    }

    client {
      idle-timeout = 300s
      request-timeout = 20 s
    }

    host-connection-pool {
      max-connections = 128
      max-open-requests = 128
    }
  }

}

clustering {
  # ip = "127.0.0.1"
  # ip = ${?CLUSTER_IP}
  # port = 8088 -- define the default port for your app
  # port = ${?CLUSTER_PORT}
  seed-ip = "127.0.0.1"
  seed-ip = ${?CLUSTER_IP}
  seed-ip = ${?WOKEN_PORT_8088_TCP_ADDR}
  seed-port = 8088
  seed-port = ${?WOKEN_PORT_8088_TCP_PORT}
  cluster.name = "woken"
  cluster.name = ${?CLUSTER_NAME}
}
